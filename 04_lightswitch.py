# -*- coding: utf-8 -*-
"""LightSwitch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SZckRgF1yYDdhg4Kt2Y2u_VE3B0x9Zs6

**Light switch**

We expect negation of inputs


*   *_data contains value for light. 
  * 0 - light is OFF
  * 1 - light is ON
*   *_labels contains value for darkness.
  * 0 - it's not dark
  * 1 - it's dark
"""

import tensorflow as tf
import numpy as np # for multidimensional arrays

# Initialize data
train_data = np.ndarray(shape = (2,1,1))
train_data[0] = [0]
train_data[1] = [1]

train_labels = np.ndarray(shape = (2,))
train_labels[0] = 1
train_labels[1] = 0

test_data = np.ndarray(shape = (5,1,1))
test_data[0] = [0]
test_data[1] = [0]
test_data[2] = [1]
test_data[3] = [0]
test_data[4] = [1]

test_labels = np.ndarray(shape = (5,))
test_labels[0] = 1
test_labels[1] = 1
test_labels[2] = 0
test_labels[3] = 1
test_labels[4] = 0

# Trivial model with 1 input neuron, 1 hidden layer neuron and 2 output neurons
model = tf.keras.models.Sequential([
  tf.keras.layers.Flatten(input_shape=(1, 1)),
  tf.keras.layers.Dense(1, activation=tf.nn.relu),
  tf.keras.layers.Dense(2, activation=tf.nn.softmax)
])

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# Our train_data is very short (just 2 items). We need lot of epochs to get somewhere
model.fit(train_data, train_labels, epochs=500)

# See final loss and accuracy
model.evaluate(test_data, test_labels)

# Review data
predictions = model.predict(test_data)
for index, test_data_item in enumerate(test_data):
  print("Light: " + str(test_data_item) , "Prediction: " + str(predictions[index]), "Is darkness: " + str(np.argmax(predictions[index])))